<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stan&#39;s Site</title>
  <subtitle>这个人很懒，什么也没有留下。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lonelymonster.github.io/"/>
  <updated>2017-08-09T07:37:31.317Z</updated>
  <id>http://lonelymonster.github.io/</id>
  
  <author>
    <name>Tang Yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聚合和聚合根</title>
    <link href="http://lonelymonster.github.io/2017/08/09/%E8%81%9A%E5%90%88%E5%92%8C%E8%81%9A%E5%90%88%E6%A0%B9/"/>
    <id>http://lonelymonster.github.io/2017/08/09/聚合和聚合根/</id>
    <published>2017-08-09T07:34:17.412Z</published>
    <updated>2017-08-09T07:37:31.317Z</updated>
    
    <content type="html"><![CDATA[<p>聚合和聚合根是领域模型里面很重要的一个概念，其实我们在从真实世界对业务对象进行识别和概念建模的时候，关注的就是聚合根，这才是我们真正要管理的业务对象。一个对象可能有多个层次，也可能有多个子实体，但是这些子实体都不可能孤立存在，它们必须依附于一个聚合根存在，它们和根节点具有同样的生命周期。</p>
<p>如果一个客户消亡，客户联系方式，客户的多张银行账户信息将不再有任何意义。如果一张采购订单头消失，那么采购订单明细没有任何存在的意义。客户，采购订单，发票这些从真实业务中转化过来的业务对象才是真正的领域核心对象。这些对象可能在领域建模的时候会分解到多个Entity或Value Object，但是一定要意识到实际的聚合在哪里？我们真正关注的业务对象实体究竟有哪些？</p>
<p>为什么如此强调领域模型，强调聚合根的概念，因此我们在关注领域模型的时候将有助于我们打破原有的关系型数据库的思维模式，转化为对象和领域的思维模式。可以看到领域建模和聚合根的思路正是既适合于关系型数据库，也适合NoSql数据库的建模思路。因为在NoSQL持久化的时候，我们看到采购订单就是一个对象，其它明细和关联信息都是这个对象下的子实体信息，采购订单应该作为一个对象整体进行查询和存储，我们并不关系NoSQL会如何去存储这个对象。让我们正在关注领域对象，而不是去关心如何持久化。</p>
<p>聚合Aggregate就是一组相关对象的集合，我们把它作为数据修改和访问的单元。每个聚合都会有一个聚合根和聚合的边界Boundary，边界定义了在一个聚合里面内部应该有哪些实体，哪些子实体对象。定义边界的原因是我们期望对一个聚合的访问是通过聚合根点进行的，聚合里面的子实体对外界是完全封闭的。对于外部对象不应该去访问到一个聚合边界里面的子实体。</p>
<p>在一些场景下，对于一个聚合的访问，我们往往只需要查询到头信息，而不关心具体的子实体信息，这个有点类似于传统O/R Mapping里面的惰性加载。在这里也必须要考虑到。在实现和设计聚合的时候，需要考虑到这种场景，即根据需要来加载一个完整聚合中的实体和子实体，以满足性能的需要。如何对应关系型数据库，对一个聚合实际的新增变更处理则可能涉及到多个数据表的多次操作，而这已经是仓储接口和仓储实现需要考虑的问题。现在对一个聚合的一次操作一定应该在一个完整的事务里面，以保障实际的事务完整性要求。</p>
<p>按实际对象分析思路，在领域模型中的领域对象分析应该按照从顶向下的思路进行展开，如果这样的话首先识别到的就是聚合根对象，然后再考虑对聚合根对象进行展开，在聚合根对象的展开过程中进一步细化子实体之间的关联和依赖关系。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;聚合和聚合根是领域模型里面很重要的一个概念，其实我们在从真实世界对业务对象进行识别和概念建模的时候，关注的就是聚合根，这才是我们真正要管理的业务对象。一个对象可能有多个层次，也可能有多个子实体，但是这些子实体都不可能孤立存在，它们必须依附于一个聚合根存在，它们和根节点具有同
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聚合根、实体和值对象</title>
    <link href="http://lonelymonster.github.io/2017/08/09/%E8%81%9A%E5%90%88%E6%A0%B9%E3%80%81%E5%AE%9E%E4%BD%93%E5%92%8C%E5%80%BC%E5%AF%B9%E8%B1%A1/"/>
    <id>http://lonelymonster.github.io/2017/08/09/聚合根、实体和值对象/</id>
    <published>2017-08-09T06:48:53.447Z</published>
    <updated>2017-08-09T06:52:46.548Z</updated>
    
    <content type="html"><![CDATA[<p>1.聚合根、实体、值对象的区别？</p>
<p>从标识的角度：</p>
<p>聚合根具有全局的唯一标识，而实体只有在聚合内部有唯一的本地标识，值对象没有唯一标识，不存在这个值对象或那个值对象的说法；</p>
<p>从是否只读的角度：</p>
<p>聚合根除了唯一标识外，其他所有状态信息都理论上可变；实体是可变的；值对象是只读的；</p>
<p>从生命周期的角度：</p>
<p>聚合根有独立的生命周期，实体的生命周期从属于其所属的聚合，实体完全由其所属的聚合根负责管理维护；值对象无生命周期可言，因为只是一个值；</p>
<p>2.聚合根、实体、值对象对象之间如何建立关联？</p>
<p>聚合根到聚合根：通过ID关联；</p>
<p>聚合根到其内部的实体，直接对象引用；</p>
<p>聚合根到值对象，直接对象引用；</p>
<p>实体对其他对象的引用规则：1）能引用其所属聚合内的聚合根、实体、值对象；2）能引用外部聚合根，但推荐以ID的方式关联，另外也可以关联某个外部聚合内的实体，但必须是ID关联，否则就出现同一个实体的引用被两个聚合根持有，这是不允许的，一个实体的引用只能被其所属的聚合根持有；</p>
<p>值对象对其他对象的引用规则：只需确保值对象是只读的即可，推荐值对象的所有属性都尽量是值对象；</p>
<p>3.如何识别聚合与聚合根？</p>
<p>明确含义：一个Bounded Context（界定的上下文）可能包含多个聚合，每个聚合都有一个根实体，叫做聚合根；</p>
<p>识别顺序：先找出哪些实体可能是聚合根，再逐个分析每个聚合根的边界，即该聚合根应该聚合哪些实体或值对象；最后再划分Bounded Context；</p>
<p>聚合边界确定法则：根据不变性约束规则（Invariant）。不变性规则有两类：1）聚合边界内必须具有哪些信息，如果没有这些信息就不能称为一个有效的聚合；2）聚合内的某些对象的状态必须满足某个业务规则；</p>
<p>Link：<a href="http://www.cnblogs.com/netfocus/archive/2012/02/12/2347938.html" target="_blank" rel="external">http://www.cnblogs.com/netfocus/archive/2012/02/12/2347938.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.聚合根、实体、值对象的区别？&lt;/p&gt;
&lt;p&gt;从标识的角度：&lt;/p&gt;
&lt;p&gt;聚合根具有全局的唯一标识，而实体只有在聚合内部有唯一的本地标识，值对象没有唯一标识，不存在这个值对象或那个值对象的说法；&lt;/p&gt;
&lt;p&gt;从是否只读的角度：&lt;/p&gt;
&lt;p&gt;聚合根除了唯一标识外，其他
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>你好世界</title>
    <link href="http://lonelymonster.github.io/2017/08/09/helloworld/"/>
    <id>http://lonelymonster.github.io/2017/08/09/helloworld/</id>
    <published>2017-08-09T02:54:56.997Z</published>
    <updated>2017-08-09T02:55:15.941Z</updated>
    
    <content type="html"><![CDATA[<p>这个人很懒，什么也没有留下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个人很懒，什么也没有留下。&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DDD（领域驱动设计）</title>
    <link href="http://lonelymonster.github.io/2017/08/09/DDD/"/>
    <id>http://lonelymonster.github.io/2017/08/09/DDD/</id>
    <published>2017-08-09T02:51:43.863Z</published>
    <updated>2017-08-09T02:56:08.599Z</updated>
    
    <content type="html"><![CDATA[<p>分层架构<br>最初层次只分为三层：表现层、业务层和持久层；DDD告诉我们如何实现业务层。</p>
<p>业务层将细分为两个层次：应用层和领域层。它们的定义是：<br>应用层：定义软件可以完成的工作，并且指挥具有丰富含义的领域对象来解决问题，保持精练；不包括业务规则或知识，无业务情况的状态；<br>领域层：负责表示业务概念、业务状态的信息和业务规则，是业务软件核心。</p>
<p>领域层模型种类<br>传统模型分为两种：实体（Entity）和值对象（Value Object），现在服务（Service）成为第三种模型元素。<br>实体（Entity）定义：通过一系列连续性（continuity）和标识（identity　ID）来定义；个人认为它和分析领域的四色原型中的PPT原型非常类似，可以看成是PPT原型延续。<br>值对象（Value Object）：如果一个对象代表了领域的某种描述性特征，且没有概念性的标识。它是四色原型中Description原型延续。<br>Eric认为：服务Service是描述领域概念最自然的方式，是四色原型的MI原型的延续， 优秀服务3个特征：<br>　　1.与领域概念相关的操作行为、但不是实体和值对象中固有的部分。<br>　　2.接口根据领域模型中其他元素定义<br>    3.操作是无状态的。</p>
<p>四色原型及聚合设计<br>PartPlaceThing：简称PPT，用淡绿色表示，常见的PPT有：部门、岗位、人员、地点、物品等。<br>Description：简称Des，用淡蓝色表示，主要用来对PPT进行描述，常见的Des有：部门类型、岗位层级、人员类型、地点区域、物品分类等。<br>Role：用淡黄色表示，主要表示PPT在某个场景下扮演的角色，常见的角色有：财务类部门、管理类岗位、请假者、销售点、产品等。<br>MomentInterval：简称MI，用淡红色表示，主要表示在一刻或一段时间内发生的一件事情，常见的MI有：部门移动、岗位移动、员工离职、产品销售等。<br>MomentInteval：简称MIDetail，用淡红色表示，主要表示MI的明细，常见的MIDetail有销售明细、入库明细、出库明细等。<br>四色原型可以用这句话进行描述：某个人（Party）的角色（PartyRole）在某个地点（Place）的角色（PlaceRole）用某个东西（Thing）的角色（ThingRole）做了某件事情（MomentInterval）。<br>第一步：识别模型<br>第二步：识别关联<br>第三步：划分聚合<br>•    MI和MIDetail是一个聚合，MI是聚合根。<br>•    PPT是一个聚合，PPT是一个聚合根。如果Des只“描述”PPT，那么这个Des会作为一个值对象隶属于属于PPT所在的聚合。<br>•    Des是一个聚合，Des是一个聚合根。前提你想“跟踪”Des关联的PPT。<br>•    Role不属于聚合，Role是一个带状态的领域服务，Role采用装饰器模式装饰PPT。<br>第四步：精简关联</p>
<p>领域对象的生命周期Scope<br>在生命周期中维护对象的完整性。<br>避免模型由于管理生命周期的复杂性而陷入困境。<br>有三个模式来处理：<br>聚合（Aggregate）：定义清晰的所有权和边界使模型更加紧凑，避免出现盘根错节的对象关系网；<br>工厂（Factory）和组合（Respository）。<br>当一个对象生命周期之始，使用工厂和组合提供了访问和控制模型对象的方法，完善了MDD。 建立聚合的模型，并且把工厂和组合加入设计中来，可以使我们系统地对模型对象进行管理。 聚合圈出一个范围，在这个范围中，对象无论在哪个生命周期，保持不变性。<br>但是，Eric明确告诉我们，领域模型的工厂属于应用层，也就是还是应该处于业务层的，这样好处很多，业务层设计根本无需从Hibernate等持久层框架获得，而是从自己的工厂获得。组合（Respository）又被翻译成仓储，主要用来返回一批对象，查询组合常用来返回批量查询结果。（贫血模型）</p>
<p>失血模型：模型仅仅包含数据的定义和getter/setter方法，业务逻辑和应用逻辑都放到服务层中。这种类在Java中叫POJO，在.NET中叫POCO。（不推荐）<br>贫血模型：贫血模型中包含了一些业务逻辑，但不包含依赖持久层的业务逻辑。这部分依赖于持久层的业务逻辑将会放到服务层中。可以看出，贫血模型中的领域对象是不依赖于持久层的。<br>充血模型：充血模型中包含了所有的业务逻辑，包括依赖于持久层的业务逻辑。所以，使用充血模型的领域层是依赖于持久层，简单表示就是 UI层-&gt;服务层-&gt;领域层&lt;-&gt;持久层。<br>胀血模型：胀血模型就是把和业务逻辑不想关的其他应用逻辑（如授权、事务等）都放到领域模型中。我感觉胀血模型反而是另外一种的失血模型，因为服务层消失了，领域层干了服务层的事，到头来还是什么都没变。（不推荐）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分层架构&lt;br&gt;最初层次只分为三层：表现层、业务层和持久层；DDD告诉我们如何实现业务层。&lt;/p&gt;
&lt;p&gt;业务层将细分为两个层次：应用层和领域层。它们的定义是：&lt;br&gt;应用层：定义软件可以完成的工作，并且指挥具有丰富含义的领域对象来解决问题，保持精练；不包括业务规则或知识，
    
    </summary>
    
    
  </entry>
  
</feed>
